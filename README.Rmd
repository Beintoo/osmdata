---
output: rmarkdown::github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r opts, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  width = 120,
  comment = "#>",
  fig.retina = 2,
  fig.path = "README-"
)
```


[![Build Status](https://travis-ci.org/osmdatar/osmdata.svg?branch=master)](https://travis-ci.org/osmdatar/osmdata) [![codecov](https://codecov.io/gh/osmdatar/osmdata/branch/master/graph/badge.svg)](https://codecov.io/gh/osmdatar/osmdata)


![](./fig/title.png)


`osmdata` is an R package for accessing OpenStreetMap (OSM) data using the
[Overpass API](http://wiki.openstreetmap.org/wiki/Overpass_API).  The Overpass
API (or OSM3S) is a read-only API that serves up custom selected
parts of the OSM map data. Map data are returned as
[`sp`](https://cran.r-project.org/package=sp) objects.


### Installation

```{r install, eval=FALSE}
devtools::install_github("osmdatar/osmdata")
```

```{r usage2, echo=FALSE}
wd <- getwd ()
while (length (grep ('osmdata', getwd ())) > 0) setwd ("..")
devtools::load_all ("osmdata")
#devtools::load_all ("osmdata", recompile=TRUE)
#devtools::document ("osmdata")
#goodpractice::gp ("osmdata")
setwd (wd)
#testthat::test_dir ("./tests/")
```

Current verison:

```{r}
library(osmdata)
packageVersion("osmdata")
```

### Usage

[Overpass API](http://wiki.openstreetmap.org/wiki/Overpass_API) queries can be
built from a base query constructed with `opq` followed by `add_features`. The
corresponding OSM objects are then downloaded and converted to `sp` objects with
`overpass_query`. For example,

```{r query1}
q0 <- opq (bbox=c(-0.12,51.11,-0.11,51.12)) # Central London, U.K.
q1 <- add_feature (q0, key='building')
bh <- overpass_query (q1)
class (bh); sapply (bh, summary)
```

or,

```{r query2}
q2 <- add_feature (q0, key='highway', value='tertiary')
hs <- overpass_query (q2)
class (hs); sapply (hs, summary)
```

```{r junk}
q1 <- opq (bbox=c(-0.12,51.51,-0.1,51.52)) 
q1 <- add_feature (q1, key='building')
b <- overpass_query (q1)
summary (overpass_query (q1))

q2 <- opq (bbox=c(-0.12,51.51,-0.11,51.52)) 
q2 <- add_feature (q2, key='highway', value='primary')
hs <- overpass_query (q2)
summary (hs)

q3 <- opq (bbox=c(-0.12,51.51,-0.1,51.52)) 
q3 <- add_feature (q3, key='building')
q3 <- add_feature (q3, key='highway', 'secondary')
summary (overpass_query (q3))
```

It acts as a database over the web: the client sends
a query to the API and gets back the data set that corresponds to the query.  To
explore simple Overpass queries interactively, try [overpass
turbo](http://overpass-turbo.eu/).

Here's an [RPub](http://rpubs.com/hrbrmstr/overpass) for `overpass` that I'll
continually update as this goes (that will eventually be a vignette).

Unlike the main API, which is optimized for editing, Overpass API is optimized
for data consumers that need a few elements within a glimpse or up to roughly
100 million elements in some minutes, both selected by search criteria like e.g.
location, type of objects, tag properties, proximity, or combinations of them.

Overpass API has a powerful query language (language guide, language reference,
an IDE) beyond XAPI, but also has a compatibility layer to allow a smooth
transition from XAPI.

This package pairs nicely with [nominatim](http://github.com/hrbrmstr/nominatim).

The following functions are implemented:

- `add_feature`:	Add a feature to an Overpass query
- `available_features`:	List recognized features in OSM Overpass
- `available_tags`:	List tags associated with a feature
- `bbox_to_string`:	Convert a named matrix or a named vector (or an unnamed vector) return a string
- `opq`:	Begin building an Overpass query
- `overpass_query`:	Issue OSM Overpass Query
- `overpass_status`:	Retrieve status of the Overpass API
- `read_osm`:	Read an XML OSM Overpass response from path

### Usage

```{r csv, cache=TRUE, eval=FALSE}
# CSV example
osmcsv <- '[out:csv(::id,::type,"name")];
area[name="Bonn"]->.a;
( node(area.a)[railway=station];
  way(area.a)[railway=station];
  rel(area.a)[railway=station]; );
out;'

obj <- overpass_query(osmcsv)
read.table(text = obj, sep="\t", header=TRUE, 
           check.names=FALSE, stringsAsFactors=FALSE)

```

```{r only_nodes, eval=FALSE}
# just nodes
only_nodes <- '[out:xml];
node
  ["highway"="bus_stop"]
  ["shelter"]
  ["shelter"!~"no"]
  (50.7,7.1,50.8,7.25);
out body;'

pts <- overpass_query(only_nodes)$osm_points
sp::plot(pts)
```
![](./fig/README-only_nodes.png)

```{r nodes_and_ways, eval=FALSE}
# ways & nodes
nodes_and_ways <- '[out:xml];
(node["amenity"="fire_station"]
    (50.6,7.0,50.8,7.3);
  way["amenity"="fire_station"]
    (50.6,7.0,50.8,7.3);
  rel["amenity"="fire_station"]
    (50.6,7.0,50.8,7.3););
(._;>;);
out;'

wys <- overpass_query(nodes_and_ways)
sp::plot(wys$osm_lines)
```
![](./fig/README-nodes_and_ways.png)

```{r actual_ways, eval=FALSE}
# xml version of the query
actual_ways <- '<osm-script output="xml">
  <query type="way">
    <bbox-query e="7.157" n="50.748" s="50.746" w="7.154"/>
  </query>
  <union>
    <item/>
    <recurse type="down"/>
  </union>
  <print/>
</osm-script>'

awy <- overpass_query(actual_ways)
sp::plot(awy$osm_lines)
```
![](./fig/README-actual_ways.png)

```{r london-motorways, eval=FALSE}
# more complex example: motorways surrounding London
# warning: may take a few minutes to run
from_robin <- '[out:xml][timeout:100];
(
  node["highway"="motorway"](51.24,-0.61,51.73,0.41);
  way["highway"="motorway"](51.24,-0.61,51.73,0.41);
  relation["highway"="motorway"](51.24,-0.61,51.73,0.41);
);
out body;
>;
out skel qt;'

res <- overpass_query(from_robin)
frb <- res$osm_lines
```
![](./fig/README-london-motorways.png)


### Test Results

```{r test}
date()

testthat::test_dir("tests/")
```

### Code of Conduct

Please note that this project is released with a [Contributor Code of Conduct](CONDUCT.md). 
By participating in this project you agree to abide by its terms.
