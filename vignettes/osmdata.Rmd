---
title: "1. osmdata"
author: "Mark Padgham"
date: "`r Sys.Date()`"
bibliography: overpass-refs.bib
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{1. osmdata}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## 1. Introduction

`osmdata` is an R package for downloading and using data from OpenStreetMap (OSM).
OSM is a global open access mapping project, which anyone
can contribute to or access data from [@OpenStreetMap].
People new to OSM are recommended to explore what the maps look like at
[www.openstreetmap.org/](www.openstreetmap.org/), where you can also sign-up
to edit the map for your local area.

The development version of the `osmdata` R package can be installed with the
`devtools` package using the following command:

```{r install, eval=FALSE}
devtools::install_github("osmdatar/osmdata")
```
```{r, echo=FALSE, message=FALSE}
devtools::load_all ("..", export_all=FALSE)
```

Once installed, it can be loaded in the usual way:

```{r}
library(osmdata)
```

`osmdata` uses the [`overpass` API](http://overpass-api.de) to download
OpenStreetMap (OSM) data and can convert the results to either [Simple Features
(SF)](https://cran.r-project.org/package=sf) or
[`Spatial`](https://cran.r-project.org/package=sp) objects, respectively defined
by the `R` packages `sf` and `sp`.

`overpass` is a C++ library that serves OSM data over the web.  `osmdata`
translates requests into `overpass`'s own query language, beginning with the
`osmdata` function `opq()`, which accepts the single argument of a bounding box.

```{r opq1}
q <- opq(bbox = c(51.1, 0.1, 51.2, 0.2))
```

Bounding boxes may also be defined by simply passing the name of a desired area, which does not have be precise:

```{r opq2}
q <- opq(bbox = "Greater London, U.K.")
identical(opq(bbox = "Greater London, U.K."), opq(bbox = "greater london uk"))
```

Following the initial `opq()` call, `osmdata` queries are built by adding one or
more 'features', which are specified in terms of `key-value` pairs (see 
[wiki.openstreetmap.org/wiki/](http://wiki.openstreetmap.org/wiki) for detailed 
[description of features](https://wiki.openstreetmap.org/wiki/Category:Keys)
and [a list of all OSM keys](https://wiki.openstreetmap.org/wiki/Category:Keys)). 
The `osmdata` function `available_features()` returns the comprehensive list of
feature keys currently used in OSM.
```{r features, eval=FALSE}
head (available_features ())
```
```{r, echo=FALSE}
c ("4wd only",  "abandoned", "abutters",  "access",    "addr",      "addr:city")
```
For example, all paths, ways, and roads are designated in OSM with
`key=highway`, so that a query all motorways in greater London (UK) can be
constructed as follows:
```{r opq3}
q <- opq(bbox = "greater london uk")
q <- add_feature(q, key = "highway", value = "motorway")
```
The data from a query can be obtained with the two primary `osmdata` functions,
`osmdata_sf()` and `osmdata_sp()`, which return data in Simple Features (`sf`)
and Spatial (`sp`) formats, respectively.
```{r osmdata_sf1, eval=FALSE}
osmdata_sf (q)
```
```{r osmdata_sf1-output, echo=FALSE}
msg <- c ("Object of class 'osmdata' with:\n",
"                 $bbox : 51.2867602,-0.510375,51.6918741,0.3340155\n",
"        $overpass_call : The call submitted to the overpass API\n",
"            $timestamp : [ Mon Mar  6 20:49:04 2017 ]\n",
"           $osm_points : 'sf' Simple Features Collection with 4564 points\n",
"            $osm_lines : 'sf' Simple Features Collection with 688 linestrings\n",
"         $osm_polygons : 'sf' Simple Features Collection with 0 polygons\n",
"       $osm_multilines : 'sf' Simple Features Collection with 0 multilinestrings\n",
"    $osm_multipolygons : 'sf' Simple Features Collection with 0 multipolygons")
message (msg)
```
`osmdata_sp (q)` returns the equivalent data as `SpatialPointsDataFrame` and
`SpatialLinesDataFrame` objects.


## 2. The overpass API

The `overpass` API [is](http://wiki.openstreetmap.org/wiki/Overpass_API)

> a read-only API that serves up custom selected parts of the OSM map data.

The syntax of `overpass` queries is powerful yet not easy to learn. `osmdata`
simplifies queries so that OSM data can be extracted with very little
understanding of the `overpass` query syntax, although it is still possible to
submit arbitrarily complex `overpass`  queries via `osmdata`.  An excellent
place to explore `overpass` queries specifically and OSM data in general is the 
online interactive query builder at [overpass-turbo](http://overpass-turbo.eu/),
which includes a helpful corrector function for incorrectly formatted queries.
Examples of its functionality in action can be found on the 
[OpenStreetMap wiki](http://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_API_by_Example),
with full details of the `overpass`
query language given in the 
[Query Language Guide](http://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL) 
as well as the 
[overpass API Language Guide](http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide).

The actual query submitted to `overpass` by an `osmdata` query can be obtained
with the function `qry_to_string()`.
`osmdata` queries can be converted to equivalent `overpass` queries 
provides a function `qry_to_string`
The result is a list of class `overpass_query` that can be converted into
URLs as follows:

```{r, eval=FALSE}
qry_to_string(q)
```
```{r, echo=FALSE}
msg <- c ("[out:xml][timeout:25];\n",
"(\n",
"  node\n",
"    [\"highway\"=\"motorway\"]\n",
"    (51.2867602,-0.510375,51.6918741,0.3340155);\n",
"  way  \n",
"    [\"highway\"=\"motorway\"]\n",
"    (51.2867602,-0.510375,51.6918741,0.3340155);\n",
"  relation  \n",
"    [\"highway\"=\"motorway\"]\n",
"    (51.2867602,-0.510375,51.6918741,0.3340155);\n",
");\n",
"(._;>);out body;")
message (msg)
```
The resultant output may be pasted directly into the 
[online interactive query builder](http://overpass-turbo.eu/) (and has been
somewhat eformatted from direct `qry_to_string()` output to reflect typical
`overpass` formatting).


### 2.1. osmdata queries

As mentioned, `overpass` has its own query language which largely works by
extracting data based on specific combinations of `key-value` pairs, with
`osmdata` implementing a simplified version. 

As demonstrated above, an `osmdata` query begins by specifying a bounding box
with the function `opq()`, followed by specifying desired OSM features with
`add_feature()`.  

```{r kunming}
q <- opq(bbox = "Kunming, China")
q1 <- add_feature(q, key = "natural", value = "water")
q2 <- add_feature(q1, key = "name:en", value = "Dian", exact = FALSE)
```

The parameter `exact=FALSE` controls the two ways of matching `key-value` pairs
in `osmdata`: Either exactly and entirely, or through a partial string match.
With the default `exact=TRUE`, this query would only return objects named
"Dian", and not, for example, any named "Lake Dian". Using `exact=FALSE` will
return "Lake Dian" through just specifying `value="Dian"`.

Each successive feature added with `add_feature()` is added to previous
features, so, for example, extending the previous query by an additional
`key-value` pair to 
```{r kunming2}
q3 <- add_feature(q2, key = "highway")
```
will request all objects that are both water bodies with names matching "Dian"
**AND** that are also highways. Unsurprisingly, this query returns no data,
but the previous queries do: the filtering is more restrictive with
each feature added with `add_feature()`.

As demonstrated above, the primary `osmdata` functions simply pass these queries
to `overpass` via either `osmdata_sf()` or `osmdata_sp()`, and return OSM data
in corresponding `sf` or `sp` format. Both of these functions also accept
direct `overpass` queries, such as those produced by the `osmdata` function
`qry_to_string()`, or copied directly from the [`overpass-turbo` query
builder](overpass-turbo.eu).

```{r, eval=FALSE}
qstr <- qry_to_string (q)
dat <- osmdata_sf (qstr)
```
The resultant object is of class `osmdata`, the details of which are described
below.
```{r, eval=FALSE}
class (dat)
```
```{r, echo=FALSE}
c ("list", "osmdata")
```

In summary, `osmdata` queries are generally simplified versions of potentially
more complex `overpass` queries, although arbitrarily complex `overpass` queries
may be passed directly to the primary `osmdata` functions.  As illustrated
above, `osmdata` queries are generally constructed through initiating a query
with `opq()`, and then specifying OSM features in terms of `key-value` pairs
with `add_feeature()`. 

At its simplest, `add_feature()` requires a single `key`, which by default will
return all objects specifying any value for that `key`: 

```{r opq-london, eval=FALSE}
q <- opq(bbox = "London City, U.K.")
q <- add_feature(q, key = "highway")
q <- add_feature(q, key = "name")
```
`osmdata` will use that query to return all named highways within the requested
bounding box. Note that `key` specifications are requests for features which
must include those keys, yet most features will also include many other keys,
and thus `osmdata` objects generally list a large number of distinct keys.

### 3.1. Query example

To appreciate query building in more concrete terms, let's imagine that we
wanted to find all cycle paths in Seville, Spain:

```{r}
q0 <- opq("Seville")
q1 <- add_feature(q0, key = "highway", value = "cycleway")
cway_sev <- osmdata_sp(q1)
sp::plot(cway_sev$osm_lines)
```

Now imagine we want to make a more specific query that only extract designated
cycleways or those which are bridges. Combining these into one query will return
only those that are designated cycleways **AND** that are bridges:
```{r, eval=FALSE}
q2 <- add_feature(q1, key = "bicycle", value = "designated")
q2 <- add_feature(q2, key = "bridge", value = "yes")
cway_sev_bicycle_des_bridge <- osmdata_sf(q2)
nrow (des_bike_and_bridge$osm_points); nrow (des_bike_and_bridge$osm_lines)
```
```{r, echo=FALSE}
c (7, 3)
```
That query returns only 7 points and 3 lines.  Designed cycleways **OR** bridges
can be obtained through simply combining multiple `osmdata` objects with the `c`
operator:
```{r, eval=FALSE}
q2 <- add_feature(q1, key = "bicycle", value = "designated")
q3 <- add_feature(q1, key = "bridge", value = "yes")
d2 <- osmdata_sf(q2)
d3 <- osmdata_sf(q3)
des_bike_or_bridge <- c (osmdata_sf(q2), osmdata_sf(q3))
nrow (des_bike_or_bridge$osm_points); nrow (des_bike_or_bridge$osm_lines)
```
```{r, echo=FALSE}
c (208, 40)
```
And as expected, the `OR` operation produces more data than the equivalent
`AND`. (Note that the `c` operator in the above code currently generates an
error which arises in `sf`, not `osmdata`.)




## 4. The `osmdata` object

The `osmdata` extraction functions, `osmdata_sf()`, and `osmdata_sp()`, both
return objects of class `osmdata`, the structure of which is shown with the
generic print method as demonstrated above. 

Start with a new query:

```{r london-buildings}
q <- opq(bbox = c(-0.12, 51.51, -0.11, 51.52)) # Central London, U.K.
q <- add_feature(q, key = 'building')
```

```{r osmdata_with_files2a, eval=FALSE}
class(osmdata_sf(q, "buildings.osm"))
```
```{r, echo=FALSE}
c ("list", "osmdata")
```
```{r osmdata_with_files2b, eval=FALSE}
class(osmdata_sp(q, "buildings.osm"))
```
```{r, echo=FALSE}
c ("list", "osmdata")
```

The actual spatial data contained in an `osmdata` object are of either `sp`
format when extracted with `osmdata_sp()` or `sf` format when extracted with
`osmdata_sf()`. 

```{r osmdata_with_files3a, eval=FALSE}
class(osmdata_sf(q, "buildings.osm")$osm_lines)
```
```{r, echo=FALSE}
c ("sf", "data.frame")
```
```{r osmdata_with_files3b, eval=FALSE}
class(osmdata_sp(q, "buildings.osm")$osm_lines)
```
```{r, echo=FALSE}
message ('[1] "SpatialLinesDataFrame"\nattr(,"package")\n[1] "sp"')
```

Raw OSM data can also be saved as an XML document with the `osmdata_xml()`
function:
```{r osmdata_xml3, eval=FALSE}
dat <- osmdata_xml(q, file="buildings.osm")
class (dat)
```
```{r, echo=FALSE}
c ("xml_document", "xml_node")
```
This function call both returns the XML data as the object `dat`, and saves them
in the file ''buildings.osm''.  The contents of this file will be identical to
those obtained by pasting the result of `qry_to_string(q)` directly into
[`overpass-turbo`](overpass-turbo.eu), and exporting the resultant data.  Both
other primary functions (`osmdata_sf/sp()`) accept optional arguments specifying
previously downloaded files 

```{r osmdata_with_files, eval=FALSE}
dat <- osmdata_sf(q, "buildings.osm")
doc <- osmdata_xml(q, file = "bldgs2.osm")
identical(osmdata_sf(q, doc), osmdata_sf(q, "bldgs2.osm"))
```
```{r, echo=FALSE}
TRUE
```

### 4.1. The `osmdata_xml()` function

`osmdata_xml()` returns OSM data in native XML format, which are stored by
convention with the file suffix `.osm`. This function also allows raw data to
be saved to disk, as demonstrated above. The `XML` data are formatting using
the `R` package `xml2`, and may be processed within `R` using any methods
compatible with such data, or may be processed by any other software able to
load the `XML` data directly from disk.

```{r}
class(osmdata_xml(q))
```

The function `osmdata_xml()` also allows data to be saved and used for
subsequent queries through specifying a filename.

```{r osmdata_xml2, eval=TRUE}
osmdata_xml(q, "motorways.osm")
```

This downloads the raw data underlying OSM, in xml format by default.
Let's take a glimpse of this dataset:

```{r}
doc = readLines("motorways.osm")
doc[1:5] # the first 5 lines of the raw xml file
```

If you want to use this dataset in another program, like the excellent open source GIS [QGIS](http://qgis.org/en/site/) or OSM data editor [JOSM](http://wiki.openstreetmap.org/wiki/JOSM), you can do so.

In QGIS this can then be loaded via a two-step process: `Vector > OpenStreetMap > Import topology from XML...` and open the `doc.osm` file saved previously, followed by `Vector > OpenStreetMap > Export topology to SpatialLite...`.
The results are illustrated in the figure below:

![](https://cloud.githubusercontent.com/assets/1825120/23326333/7189dd04-faf4-11e6-91f1-bd1b0c366cad.png)

`osmdata` is therefore useful even if you only want to download OSM data.
The remainder of this vignette assumes that not only do you want to get OSM data using R, you also want to import and eventually process it, using R. For that you'll need to import the data into a native R class.

These downloaded data can be directly processed by passing the same
filename to `osmdata_sf/sp`.
The following function imports the data into R
as a `Spatial` object defined by the `sp` package, with:

```{r}
dat_sp <- osmdata_sp(q, "motorways.osm")
dat_sp
```
### 4.2. The `osmdata_sf()` function

`osmdata_sf()` returns OSM data in 
[Simple Features (SF)](http://www.opengeospatial.org/standards/sfo) 
format, defined by the
[Open Geospatial Consortium](http://www.opengeospatial.org), and implemented in
the `R` package [`sf`](https://cran.r-proejct.org/package=sf). This package
provides a direct interface to the `C++` 
[Graphical Data Abstraction Library (GDAL)](http://gdal.org) which also includes
a so-called [`driver` for OSM data](http://www.gdal.org/drv_osm.html). This
means that OSM data may also be read directly with `sf`, rather than using
`osmdata`. In this case, data must first be saved to disk, which can for example
be readily achieved through downloading directly from the 
[overpass interactive query builder](http://overpass-turbo.eu). 

Queries constructed in `osmdata` can also be pasted directly into `overpass
turbo`. The following example is based on this query: 

```{r trentham}
q <- opq(bbox = "Trentham, Australia")
q <- add_feature(q, key = "name") # any named objects
osmdata_xml(q, "trentham.osm")
```

`sf` can then read such data independent of `osmdata` though

```{r sf1}
sf::st_read("trentham.osm", layer = "lines")
```

The `GDAL` drivers used by `sf` can only load single 'layers' of features, for
example, `points`, `lines`, or `polygons`. In contrast, `osmdata` loads all
features simultaneously:

```{r osmdata_sf2}
osmdata_sf(q, "trentham.osm")
```

Even for spatial objects of the same type (the same 'layers' in `sf`
terminology), `osmdata` returns considerably more objects. The raw sizes of data
returned can be compared with:

```{r object-sizes}
as.numeric(object.size(osmdata_sf(q, "trentham.osm")$osm_lines) /
             object.size(sf::st_read(
             "trentham.osm", layer = "lines", quiet = TRUE
             )))
```

And the `osmdata lines` contain over five times as much data.  The primary
difference between `sf/GDAL` and `osmdata` is that the former returns only those
objects unique to each category of spatial object.  Thus OSM nodes (`points` in
`sf/osmdata` representations) include, in `sf/GDAL` representation, only those
points which are not part of any other objects (such as lines or polygons). In
contrast, the `osm_points` object returned by `osmdata` includes all points
regardless of whether or not these are represented in other spatial objects.
Similarly, `line` objects in `sf/GDAL` exclude any lines that are part of other
objects such as `multipolygon` or `multiline` objects.

This processing of data by `sf/GDAL` has two important implications:

1. An implicit hierarchy of spatial objects is enforced through including
elements of objects only at their 'highest' level of representation, where
`multipolygon` and `multiline` objects are assumed to be at 'higher' levels
than `polyon` or `line` objects, and these in turn are at 'higher' levels than
`point` objects. `osmdata` makes no such hierarchical assumptions.

2. All OSM are structured by giving each object a unique identifier so that the
components of any given object (the nodes of a line, for example, or the lines
of a multipolygon) can be referenced in terms of these identifiers alone. This
enables the full details for any component of a given object to be extracted by
examining that component. The `sf/GDAL` representation obviates this ability
through removing these IDs and reducing everything to geometries alone (which
is, after all, why it is called '*Simple* Features'). This means, for example,
that the `key-value` pairs of the `line` or `polygon` components of
`multipolygon` can never be extracted from an `sf/GDAL` representation. In
contrast, `osmdata` retains all unique identifiers for all OSM objects, and so
readily enables, for example, the properties of all `point` objects of a `line`
to be extracted.

Finally, note that `osmdata` will generally extract OSM data considerably
faster than equivalent `sf/GDAL` routines (as detailed [here](git-wiki)).

### 4.3. The `osmdata_sp()` function

As with `osmdata_sf()` described above, OSM data may be converted to `sp`
format without using `osmdata` via the `sf` functions demonstrated below: 

```{r sf_sp, eval=TRUE}
dat <- sf::st_read("buildings.osm", layer = "multipolygons")
dat_sp <- as(dat, "Spatial")
class(dat_sp)
```

These data are extracted using the GDAL, and so suffer all of the same
shortcomings mentioned above. Note differences in the amount of data returned:

```{r}
dim(dat_sp)
dim(osmdata_sf(q, doc = 'buildings.osm')$osm_polygons)
dim(osmdata_sf(q, doc = 'buildings.osm')$osm_multipolygons)
```

```{r, echo=FALSE}
for(f in list.files(pattern="\\.osm"))
    if(file.exists(f)) file.remove(f)
```

## 5. Recursive searching

OSM data are structured in three hierarchical levels:

1. `nodes` representing spatial points 

2. `ways` representing lines, both as `polygons` (with connected ends) and
   non-polygonal `lines`

3. `relations` representing more complex objects generally comprising
   collections of `ways` and/or `nodes. Examples include `multipolygon
   relations` comprising an outer polygon (which may itself be made of several
   distinct `ways` which ultimately connect to form a single circle), and
   several inner polygons.

`osmdata` contains several functions which can be used to extract the components
of individual objects.

1. `osm_points` extracts all `point` or `node` objects 

2. `osm_lines` extracts all `way` objects that are `lines` (that are, that are
   not `polygons`) 

3. `osm_polygons` extracts all `polygon` objects

4. `osm_multilines` extracts all `multiline` objects; and

5. `osm_multipolygons` extracts all `multipolygon` objects.

This is illustrated with data already loaded (note the need to specify the ids of features that comprise the result):

```{r}
id <- as.character(cway_sev$osm_points$osm_id)
cway_lines <- osm_lines(dat = cway_sev, id = id)
```

## 6. Related Packages

@eugster_osmar:_2012 describe `osmar`, an R package for handling OSM data
that enables visualisation, search and even rudimentary routing operations.
`osmar` is not user friendly or able to download OSM data flexibly,
as reported in an [early tutorial](http://eprints.whiterose.ac.uk/77643/)
comparing R and QGIS for handling OSM data [@lovelace_harnessing_2014].

`osmdata` builds on two previous R packages:
`osmplotr`, a package [available from CRAN](https://cran.r-project.org/package=osmplotr)
for accessing and plotting OSM data [@osmplotr]
and `overpass`, a [GitHub package](https://github.com/hrbrmstr/overpass)
by Bob Rudis that provides an R interface to the 
[overpass](http://overpass-api.de/) API.

## 7. References
